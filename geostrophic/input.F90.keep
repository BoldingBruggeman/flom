! Copyright (C) 2020 Bolding & Bruggeman
!> Costum input for reading WOA files to provide salinity and temperature.

MODULE input_manager

   USE, INTRINSIC :: ISO_FORTRAN_ENV
   use netcdf
   use datetime_module

   IMPLICIT NONE

!-----------------------------------------------------------------------------

   PRIVATE  ! Private scope by default

!  Module constants

!  Module types and variables

   type, public :: type_netcdf_input
      !! version: v0.1

      character(len=256) :: f
        !! Input file name
      character(len=256) :: v
        !! NetCDF variable name
      integer, private :: ncid
        !! NetCDF id
      integer, private :: varid
        !! variable id
      integer, private, dimension(4) :: start, count
        !! arguments to the NetCDF get routine
      real(real64), dimension(:,:,:), pointer :: var 

      contains

!      procedure :: initialize => initialize_data
!      procedure :: get => get_data
!      procedure :: close => data_data
      procedure :: initialize => initialize_netcdf_input
!      procedure :: print_info => print_info_netcdf_input
!      procedure, deferred :: get => get_netcdf_input
!      procedure :: getsize => get_netcdf_variable_size
      procedure :: get => get_netcdf_input
      procedure :: close => close_netcdf_input

   end type type_netcdf_input

   type(type_netcdf_input), public :: Tinput,Sinput

!-----------------------------------------------------------------------------

CONTAINS

!-----------------------------------------------------------------------------

SUBROUTINE initialize_netcdf_input(self)
   !! Open a NetCDF file and get a variable id

   IMPLICIT NONE

!  Subroutine arguments
   class(type_netcdf_input), intent(inout) :: self

!  Local constants

!  Local variables
   integer :: rc
   integer :: i,n
!-----------------------------------------------------------------------------
   ! open the NetCDF file with the bathymetry
   call check( nf90_open(trim(self%f), NF90_NOWRITE, self%ncid) )

   ! check existence of the variable in the file
   call check(nf90_inq_varid(self%ncid, trim(self%v), self%varid))

   self%start(1) = 1; self%count(4) = 460 ! lat
   self%start(2) = 1; self%count(3) = 480 ! lon
   self%start(3) = 1; self%count(2) = 1 ! time
   self%start(4) = 1; self%count(1) = 57 ! depth

   return
END SUBROUTINE initialize_netcdf_input

!-----------------------------------------------------------------------------

SUBROUTINE get_netcdf_input(self,n)
   !! Read variable at time indes n

   IMPLICIT NONE

! Subroutine arguments
   class(type_netcdf_input), intent(inout) :: self
   integer, intent(in) :: n

! Local constants

! Local variables
!-----------------------------------------------------------------------------
   self%start(2) = n
!   call self%print_info()
   call check(nf90_get_var(self%ncid,self%varid,self%var,start=self%start,count=self%count))
   return
END SUBROUTINE get_netcdf_input

!-----------------------------------------------------------------------------

SUBROUTINE close_netcdf_input(self)
   !! Read the bathymetry from an external file and sets the mask

   IMPLICIT NONE

!  Subroutine arguments
   class(type_netcdf_input), intent(inout) :: self

!  Local constants

!  Local variables
!-----------------------------------------------------------------------------
   call check( nf90_close(self%ncid) )
   self%ncid=-1
   return
END SUBROUTINE close_netcdf_input

!-----------------------------------------------------------------------------

subroutine  check(status,error_handler)
   integer, intent (in) :: status
   integer, intent(inout), optional :: error_handler

   if (present(error_handler)) then
      error_handler = 1
   else 
      if(status /= nf90_noerr) then 
        print *, trim(nf90_strerror(status))
        stop "Stopped"
      end if
   end if
   return
end subroutine check 

!-----------------------------------------------------------------------------

END MODULE input_manager

#if 0
   TYPE, extends(type_input_data) :: type_netcdf_2d_real64
     !! netcdf_2d_real64 extends type_netcdf_input
      integer :: dimids(2)
      integer :: dimlens(2) 
      real(real64), dimension(:,:), pointer :: data
   contains
      procedure, :: get => get_netcdf_2d_real64
   END TYPE type_netcdf_2d_real64

   TYPE, extends(type_input_data) :: type_scalar_data
     !! 0D_data extends type_input_data
      integer :: data_rank=0
      real(real64), pointer :: data
   contains
      procedure :: initialize => initialize_netcdf_input
      procedure, deferred :: get => get_netcdf_input
      procedure :: close => close_netcdf_input
   END TYPE type_scalar_data

   TYPE, extends(type_input_data) :: type_1d_data
     !! 1D_data extends type_input_data
      integer :: data_rank=1
      real(real64), dimension(:), pointer :: data
   contains
   END TYPE type_1d_data

   TYPE, extends(type_input_data) :: type_2d_data
     !! 2D_data extends type_input_data
      integer :: data_rank=2
      real(real64), dimension(:,:), pointer :: data
   contains
   END TYPE type_2d_data

   TYPE, extends(type_input_data) :: type_3d_data
     !! 3D_data extends type_input_data
      integer :: data_rank=3
      real(real64), dimension(:,:,:), pointer :: data
   contains
   END TYPE type_3d_data

   PUBLIC type_scalar_data, type_1d_data, type_2d_data, type_3d_data

#endif
